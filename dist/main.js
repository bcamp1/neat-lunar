/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/botcontroller.js":
/*!******************************!*\
  !*** ./src/botcontroller.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bot\": () => (/* binding */ Bot)\n/* harmony export */ });\n/* harmony import */ var _ship__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ship */ \"./src/ship.js\");\n\n\nclass Bot {\n  constructor (ships, two, ground) {\n    this.id = ships.length\n    this.ship = new _ship__WEBPACK_IMPORTED_MODULE_0__.Ship(two, 50, ground.minY - 100, 0.5, -0.1, -Math.PI / 2)\n    ships.push(this.ship)\n    // this.net.display()\n    this.dead = false\n\n    this.sensorLength = 200\n\n    this.sensorLeft = new Sensor(this.id, -Math.PI / 6, this.sensorLength, two, this.ship, ground)\n    this.sensorMiddle = new Sensor(this.id, 0, this.sensorLength, two, this.ship, ground)\n    this.sensorRight = new Sensor(this.id, Math.PI / 6, this.sensorLength, two, this.ship, ground)\n  }\n\n  setEngine (isOn) {\n    if (isOn) {\n      this.ship.engineLevel += 2\n    } else {\n      this.ship.engineLevel -= 2\n    }\n  }\n\n  turn (dir) {\n    if (dir === Direction.LEFT) {\n      this.ship.av -= 0.0001\n    } else if (dir === Direction.RIGHT) {\n      this.ship.av += 0.0001\n    }\n  }\n\n  acceptKeyboardInput (up, down, left, right) {\n    if (up) {\n      this.ship.engineLevel = 12\n    } else {\n      this.ship.engineLevel = 0\n    }\n\n    if (right) {\n      this.turn(Direction.RIGHT)\n    }\n    if (left) {\n      this.turn(Direction.LEFT)\n    }\n  }\n\n  get rotation () {\n    return this.ship.rotation\n  }\n\n  get vx () {\n    return this.ship.v.x * 10\n  }\n\n  get vy () {\n    return this.ship.v.y * 10\n  }\n\n  get x() {\n      return this.ship.translation.x\n  }\n\n  get y() {\n      return this.ship.translation.y\n  }\n\n  executeNet () {\n    if (!this.dead) {\n      var results = this.net.calculate([this.sensorLeft.value, this.sensorMiddle.value, this.sensorRight.value, this.vx, this.vy, this.rotation])\n      if (results[0] > 0) {\n        this.setEngine(true)\n      } else if (results[0] < 0) {\n        this.setEngine(false)\n      }\n\n      if (results[1] > 0) {\n        this.turn(Direction.RIGHT)\n      }\n      if (results[2] > 0) {\n        this.turn(Direction.LEFT)\n      }\n\n      if (this.ship.crashed === true || this.ship.landed === true) {\n        longestSurviving.push(this.id)\n        this.dead = true\n        console.log('Dead')\n      }\n    }\n  }\n\n  render () {\n    this.sensorLeft.render()\n    this.sensorRight.render()\n    this.sensorMiddle.render()\n\n    this.sensorMiddle.sense()\n    this.sensorLeft.sense()\n    this.sensorRight.sense()\n  }\n}\n\nclass BotController {\n  static initWorld () {\n    init()\n  }\n}\n\nclass Sensor {\n  constructor (id, theta, length, two, ship, ground) {\n    this.ground = ground\n    this.ship = ship\n    this.value = -1\n    this.botId = id\n    this.theta = theta\n    this.length = length\n    this.line = two.makeLine(0, 0, 0, 0)\n    this.line.linewidth = 1\n    this.line.stroke = \"green\"\n  }\n\n  render () {\n    var x = this.ship.translation.x\n    var y = this.ship.translation.y\n    var rotation = this.ship.rotation\n    this.line.vertices[0].x = x\n    this.line.vertices[0].y = y\n    this.line.vertices[1].x = x + (this.length * Math.cos(rotation + (Math.PI / 2) - this.theta))\n    this.line.vertices[1].y = y + (this.length * Math.sin(rotation + (Math.PI / 2) - this.theta))\n  }\n\n  /*\n    Sense\n    Returns the first point in the line that's below ground\n    Returns -1 if the entire line is above ground\n  */\n  sense () {\n    const step = 10\n    var x = this.ship.translation.x\n    var y = this.ship.translation.y\n    var rotation = this.ship.rotation\n    var cX = (Math.cos(rotation + (Math.PI / 2) - this.theta))\n    var cY = (Math.sin(rotation + (Math.PI / 2) - this.theta))\n\n    for (var i = 0; i < this.length; i += step) {\n      var pX = x + i*cX\n      var pY = y + i*cY\n      if (isBelowGround(pX, pY, this.ground)) {\n        this.line.stroke = \"red\"\n        this.value = 1\n        return i\n      }\n    }\n    this.line.stroke = \"green\"\n    this.value = -1\n    return -1\n  }\n\n}\n\nclass Direction {\n  static get LEFT () {\n    return 0\n  }\n  static get RIGHT () {\n    return 1\n  }\n  static get NONE () {\n    \treturn 2\n  }\n}\n\n\n\nfunction isBelowGround(x, y, ground) {\n  var below = ground.hitTest({x, y}, ground.vertexInfoNearest({x, y}))\n  return below\n}\n\n\n\n\n//# sourceURL=webpack://neat-lunar/./src/botcontroller.js?");

/***/ }),

/***/ "./src/camera.js":
/*!***********************!*\
  !*** ./src/camera.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n\n\nclass Camera {\n  constructor (two) {\n    this.two = two\n    this.scene = two.scene\n    this.target = {}\n  }\n\n  set chase (target) {\n    _.extend(this.target, target)\n    return this\n  }\n\n  get chase () {\n    return this.target\n  }\n\n  tick (dt) {\n    if (this.target.position && this.target.scale) {\n      let rate = dt / 1200\n\n      // for clarity, first translate\n      let center = Utils.canvas2Scene(new Two.Vector(this.two.width / 2, this.two.height / 2))\n      let delta = this.target.position.clone().subSelf(center).multiplyScalar(rate)\n      this.scene.translation.subSelf(delta) // t -= delta\n\n      // then scale\n      let ds = (this.target.scale - this.scene.scale) * rate\n      ds = Math.trunc(ds * 1000) / 1000 // this reduces jitter for large positive translations\n      this.scene.scale += ds\n      this.scene.translation.subSelf(center.multiplyScalar(ds)) // t -= center*ds\n\n      // we could combine the two translations: t -= delta + center*ds\n    }\n  }\n}\n\n\n//# sourceURL=webpack://neat-lunar/./src/camera.js?");

/***/ }),

/***/ "./src/dynamic.js":
/*!************************!*\
  !*** ./src/dynamic.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DynamicObject\": () => (/* binding */ DynamicObject)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n;\n\nclass DynamicObject {\n  constructor () {\n    this.v = new Two.Vector(0, 0)\n    this.av = 0\n    this.group = new Two.Group()\n  }\n\n  get gravity () { return -1.62 }\n  get friction () { return 0.998 }\n  get angularFriction () { return 0.95 }\n\n  get translation () { return this.group.translation }\n  set translation (t) { this.group.translation = t }\n\n  get rotation () { return this.group.rotation }\n\n  set rotation (r) {\n    this.group.rotation = r\n    if (Math.abs(this.group.rotation) > Math.PI * 2) {\n      this.group.rotation -= Math.sign(this.group.rotation) * Math.PI * 2\n    }\n  }\n\n  tick (dt) {\n    if (this.stopped) return\n\n    this.rotation += this.av * dt\n    if (Math.abs(this.group.rotation) > Math.PI * 2) {\n      this.group.rotation -= Math.sign(this.group.rotation) * Math.PI * 2\n    }\n    this.av *= this.angularFriction\n\n    let r = this.group.rotation - Math.PI / 2.0\n    let a = this.acceleration\n\n    this.v.addSelf(a.multiplyScalar(dt))\n    this.v.multiplyScalar(this.friction)\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.clampV(this.v, this.vClamp.min, this.vClamp.max)\n\n    let deltaP = this.v.clone().multiplyScalar(dt)\n    this.group.translation.addSelf(deltaP)\n  }\n\n  // subclasses will probably override...\n\n  // return x,y components of F/m\n  get acceleration () {\n    return new Two.Vector(0, 0)\n  }\n\n  // to enforce a max speed\n  get vClamp () {\n    return { min: -Number.MAX_VALUE, max: Number.MAX_VALUE }\n  }\n}\n\n\n//# sourceURL=webpack://neat-lunar/./src/dynamic.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _terrain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./terrain */ \"./src/terrain.js\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./src/camera.js\");\n/* harmony import */ var _botcontroller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./botcontroller */ \"./src/botcontroller.js\");\n/* harmony import */ var _ship__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ship */ \"./src/ship.js\");\n\n\n\n\n\n'use strict'\n\n// Math.seedrandom(`${(new Date()).getTime()}`);\nMath.seedrandom(0)\n\nlet two = new Two({ fullscreen: true, autostart: true }).appendTo(document.body)\nlet NNInfo = new Two({ width: 1500, height: 500, autostart: true }).appendTo(document.body)\n\n// resize the two canvas to allow events to flow to html header\nlet svg = document.getElementsByTagName('svg')[0]\nlet header = document.querySelector('#header')\nsvg.style.top = header.getBoundingClientRect().bottom\n\nconst smallScale = 0.6; const tinyScale = 0.2; const largeScale = 2\n\nvar ground, camera, state\n\nvar up, down, left, right, a, d\n\nvar ships = new Array()\n\ninit()\n\nfunction init () {\n  two.clear()\n  ground = new _terrain__WEBPACK_IMPORTED_MODULE_0__.Terrain(two)\n  // for (var i = 0; i < 1; i++) {\n  //     ships.push(new Ship(two, 50*i, ground.minY-100,s 0.5, -0.1, -Math.PI/2))\n  // }\n  camera = new _camera__WEBPACK_IMPORTED_MODULE_1__.Camera(two)\n  camera.chase = {}\n\n  two.scene.scale = smallScale\n  two.scene.translation.x = two.width / 2\n  two.scene.translation.y = two.height - ground.maxY * smallScale\n\n}\n\n// used for debug\nlet fps = 0\nfunction currentFPS (dt) {\n  let currentFps = (dt) ? 1000 / dt : 0\n  fps += (currentFps - fps) / 50\n  return fps\n}\n\n// two.bind('update', (frame, dt) => {\nlet x = 0\nvar render = (dt) => {\n  for (var i = 0; i < ships.length; i++) {\n    let padInfo = ground.padInfoNearest(ships[i].translation)\n\n    let groundDistance = ships[i].hitTest(ground)\n    if (groundDistance === 0) {\n      if (padInfo.pad.landTest(ships[i])) {\n        // Landed\n        padInfo.pad.fill = 'Green'\n        ships[i].stopped = true\n        ships[i].landed = true\n      } else {\n        // Crashed\n        padInfo.pad.fill = 'Red'\n        ships[i].stopped = true\n        ships[i].crashed = true\n      }\n    }\n    ships[i].tick(dt)\n  }\n  camera.tick(dt)\n}\n\n// });\n\nconst mult = 15\nvar fastforward = 1\n\n// var bots = []\nvar longestSurviving = []\n\nvar done = false\n\nvar bots = []\nvar numBots = 10\n\nfor (var i = 0; i < numBots; i++) {\n  bots.push(new _botcontroller__WEBPACK_IMPORTED_MODULE_2__.Bot(ships, two, ground))\n}\n\n// var numBots = 50\n\n// for (var i = 0; i < numBots; i++) {\n//   bots.push(new Bot())\n// }\n\n// var controlledBot = new Bot()\n\n\nsetInterval(function () {\n  for (var i = 0; i < fastforward; i++) {\n    iteration()\n    render(mult)\n  }\n}, 1)\n\nfunction iteration () {\n  if (!done) {\n    // bots\n    for (var i = 0; i < bots.length; i++) {\n      //bots[i].executeNet()\n      bots[i].acceptKeyboardInput(up, down, left, right)\n      bots[i].render()\n    }\n\n    // Camera Pan\n    if (d) {\n      two.scene.translation.x -= 3\n    }\n\n    if (a) {\n    \ttwo.scene.translation.x += 3\n    }\n  }\n}\n\nvar scale = 0.6\n\nwindow.addEventListener('wheel', event => {\n  var delta = event.wheelDelta\n  if (delta > 0) {\n    delta = 1\n    scale += 0.1\n  } else if (delta < 0) {\n    delta = -1\n    scale -= 0.1\n  }\n\n  if (scale < 0.1) {\n    scale = 0.1\n  }\n\n  two.scene.scale = scale\n  two.scene.translation.y = two.height - ground.maxY * scale\n})\n\ndocument.addEventListener('keydown', event => {\n  switch (event.keyCode) {\n    case 37: // left\n      left = true\n      break\n    case 38: // up\n      up = true\n      break\n    case 39: // right\n      right = true\n      break\n    case 40:\n      down = true\n      break\n    case 65:\n      a = true\n      break\n    case 68:\n      d = true\n      break\n    default:\n      break\n  }\n})\n\ndocument.addEventListener('keyup', event => {\n  switch (event.keyCode) {\n    case 37: // left\n      left = false\n      break\n    case 38: // up\n      up = false\n      break\n    case 39: // right\n      right = false\n      break\n    case 40:\n      down = false\n      break\n    case 65:\n      a = false\n      break\n    case 68:\n      d = false\n      break\n    default:\n      break\n  }\n})\n\n\n//# sourceURL=webpack://neat-lunar/./src/index.js?");

/***/ }),

/***/ "./src/ship.js":
/*!*********************!*\
  !*** ./src/ship.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ship\": () => (/* binding */ Ship)\n/* harmony export */ });\n/* harmony import */ var _dynamic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dynamic */ \"./src/dynamic.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n;\n\n\nclass Ship extends _dynamic__WEBPACK_IMPORTED_MODULE_0__.DynamicObject {\n  constructor (two, posX, posY, vx, vy, rotation) {\n    super()\n    this.two = two\n    this.landed = false\n    this.crashed = false\n    // geometry\n    let circle = new Two.Ellipse(0, 0, 50, 50)\n    circle.fill = \"skyblue\"\n    let rect = new Two.Rectangle(0, 50, 100, 30)\n    rect.fill = \"white\"\n    this.body = [circle, rect]\n    this.baseY = 65\n\n    let anchorsA = [new Two.Anchor(-30, 65), new Two.Anchor(-50, 100), new Two.Anchor(-60, 100)]\n    let anchorsB = [new Two.Anchor(30, 65), new Two.Anchor(50, 100), new Two.Anchor(60, 100)]\n\n    let legA = new Two.Path(anchorsA, false, false)\n    let legB = new Two.Path(anchorsB, false, false)\n\n    this.baseY = 65\n    this.flameTip = new Two.Anchor(0, this.baseY)\n    let anchorsFlame = [new Two.Anchor(-20, this.baseY), this.flameTip, new Two.Anchor(20, this.baseY)]\n    let flame = new Two.Path(anchorsFlame, false, false)\n\n    this.group = (new Two.Group()).add(circle, rect, legA, legB, flame)\n    two.add(this.group)\n\n    // colors\n    //this.group.fill = 'White'\n    flame.fill = 'Red'\n    this.group.linewidth = 5\n    this.group.scale = 0.2\n\n\n    this.hitPositions = [\n      new Ship.HitPosition(0, -50, this.group),\n      new Ship.HitPosition(48, -12, this.group),\n      new Ship.HitPosition(-48, -12, this.group),\n      new Ship.HitPosition(50, 50, this.group),\n      new Ship.HitPosition(-50, 50, this.group),\n      new Ship.HitPosition(60, 100, this.group),\n      new Ship.HitPosition(-60, 100, this.group)\n    ];\n\n    // position default is mid-canvas\n    [posX, posY] = [(posX === undefined) ? two.width / 2 : posX, (posY === undefined) ? two.height / 2 : posY]\n    this.group.translation.set(posX, posY)\n\n    // dynamics\n    this.engineLevel = 0 // 0 - 12, where force is level/8*lunarG\n    this.v = new Two.Vector(vx || 0, vy || 0)\n    this.rotation = rotation || 0\n  }\n\n  get mass () {\n    return 100000\n  }\n\n  get acceleration () {\n    let r = this.group.rotation - Math.PI / 2.0\n    let force = this.engineLevel / -8 * this.gravity\n    let ax = force / this.mass * Math.cos(r)\n    let ay = force / this.mass * Math.sin(r) - this.gravity / this.mass\n    return new Two.Vector(ax, ay)\n  }\n\n  get vClamp () {\n    return { min: -0.20, max: 0.20 }\n  }\n\n  hitTest (ground) {\n    let vertexInfo = ground.vertexInfoNearest(this.translation)\n    // out of bounds test\n    if (vertexInfo.outOfBounds) return 0\n    // cheap test\n    if (vertexInfo.distance > 50000 * this.group.scale) {\n      return vertexInfo.distance\n    }\n    // expensive test\n    for (let i = 0; i < this.hitPositions.length; i++) {\n      let hp = this.hitPositions[i].toScene()\n      let hit = ground.hitTest(hp, vertexInfo)\n      if (hit) return 0\n    }\n    return vertexInfo.distance\n  }\n\n  land () {\n    this.v = new Two.Vector(0, 0)\n    this.av = 0\n    this.engineLevel = 0\n    this.group.rotation = 0\n    this.stopped = true\n  }\n\n  get engineLevel () {\n    return this._engineLevel\n  }\n\n  set engineLevel (engineLevel) {\n    this._engineLevel = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.clamp(engineLevel, 0, 12)\n    this.flameTip.y = this.baseY + this._engineLevel * 7\n  }\n\n  set fill (color) {\n    color = color || 'White'\n    this.body.forEach(part => part.fill = color)\n  }\n\n  updateDebugShapes () {\n    if (this.debugShapes) this.two.remove(this.debugShapes)\n    let colors = ['Grey', 'Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Pink']\n    this.debugShapes = this.hitPositions.map((hp, i) => {\n      return hp.asDot(16, colors[i % colors.length])\n    })\n    this.two.add(this.debugShapes)\n  }\n}\n\nShip.HitPosition = class {\n  constructor (x, y, group) {\n    this.group = group\n    this.angle = Math.atan2(y, x)\n    this.length = Math.sqrt(x * x + y * y)\n  }\n\n  toScene () {\n    let length = this.length * this.group.scale\n    let angle = this.angle + this.group.rotation\n    let x = Math.cos(angle) * length\n    let y = Math.sin(angle) * length\n    return (new Two.Vector(x, y)).addSelf(this.group.translation)\n  }\n\n  asDot (diameter, fill) {\n    let center = this.toScene()\n    let scaledDiameter = diameter * this.group.scale\n    let dot = new Two.Ellipse(center.x, center.y, scaledDiameter, scaledDiameter)\n    if (fill) dot.fill = fill\n    dot.noStroke()\n    return dot\n  }\n}\n\n\n//# sourceURL=webpack://neat-lunar/./src/ship.js?");

/***/ }),

/***/ "./src/terrain.js":
/*!************************!*\
  !*** ./src/terrain.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Terrain\": () => (/* binding */ Terrain)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n;\n\nconst padYrange = 400\nconst maxDeflection = 280\nconst roughness = 0.7 // decrease the deflection by this on each recursion\n\nclass Terrain {\n  constructor (two) {\n    this.two = two\n    this.minX = -1 * two.width\n    this.maxX = 4 * two.width\n\n    this.minY = Number.MAX_VALUE\n    this.maxY = -Number.MAX_VALUE\n\n    this.pads = this.makePads(two.width * 0.8)\n    this.path = this.makePath(this.pads)\n\n    this.path.fill = 'rgba(0,0,0,0)'\n    let array = [this.path, ...this.pads.map(pad => pad.group)]\n\n    this.group = two.makeGroup(...array)\n\n    // draw some debug lines\n    /*\n        let minLine = new Two.Line(this.minX, this.minY, this.maxX, this.minY);\n        let zeroLine = new Two.Line(this.minX, 0, this.maxX, 0);\n        let maxLine = new Two.Line(this.minX, this.maxY, this.maxX, this.maxY);\n        minLine.stroke = 'Red';\n        zeroLine.stroke = 'Blue';\n        maxLine.stroke = 'Green';\n        this.group.add(minLine,zeroLine, maxLine);\n        */\n  }\n\n  makePads (maxSpacing) {\n    let x = this.minX; let y\n    let pads = []\n    while (x < this.maxX) {\n      x += Math.max(Math.random() * maxSpacing, padWidth * 2)\n      y = -padYrange / 2 + Math.random() * padYrange\n      let originX = x - padWidth / 2\n      let originY = y - padHeight / 2\n      let pad = new Pad(originX, originY)\n      pads.push(pad)\n    }\n    return pads\n  }\n\n  makePath (pads) {\n    let v = new Two.Anchor(this.minX, 0)\n    let padWidth2 = padWidth / 2\n    let verts = []\n    pads.forEach(pad => {\n      let padLeft = pad.leftAnchor()\n      verts = verts.concat([v, ...this.vertsBetween(v, padLeft, maxDeflection), padLeft, pad.centerAnchor()])\n      v = pad.rightAnchor()\n    })\n    return new Two.Path(verts, false, false)\n  }\n\n  vertsBetween (vl, vr, deflection) {\n    if (vr.x - vl.x < 20) return []\n    let vCtr = this.vertBetween(vl, vr, deflection)\n    return [...this.vertsBetween(vl, vCtr, deflection * roughness), vCtr, ...this.vertsBetween(vCtr, vr, deflection * roughness)]\n  }\n\n  vertBetween (vl, vr, deflection) {\n    let midx = (vr.x - vl.x) / 2 + vl.x\n    let midy = (vr.y - vl.y) / 2 + vl.y\n    let d = (Math.random() * deflection * 2) - deflection\n    let y = midy + d\n    this.minY = Math.min(this.minY, y)\n    this.maxY = Math.max(this.maxY, y)\n    return new Two.Anchor(midx, midy + d)\n  }\n\n  // vertex getter that's tolerant of vertices array bounds\n  vertAt (i) {\n    return this.path.vertices[_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp(i, 0, this.path.vertices.length - 1)]\n  }\n\n  // answer a vertexInfo object for the vertex nearest to the passed point\n  // vertexInfo keeps state that can be reused in subsequent calls to hitTest()...\n  // vertex - the nearest vertex to the paased point\n  // distance - the distance of that vertex to the passed point\n  // index - the index of that vertex in the terrain path\n  // polygon - a small polygon around the vertex that can be hit tested\n  // outOfBounds - a bool set to yes if the x value of point exceeds the xRange of the terrain\n  //\n  vertexInfoNearest (point) {\n    let vertexInfo = { distance: Number.MAX_VALUE, vert: null, index: null }\n    let center = _.sortedIndex(this.path.vertices, { x: point.x }, 'x')\n\n    if (center === 0 || center === this.path.vertices.length) {\n      let edgeVertex = this.vertAt(center)\n      vertexInfo.outOfBounds = (center === 0 && point.x < edgeVertex.x) ||\n                (center === this.path.vertices.length && point.x > edgeVertex.x)\n    }\n\n    const neighborhood = 4\n    let p = new Two.Vector(0, 0) // scratch pad\n\n    let poly = []\n    for (let i = center - neighborhood; i <= center + neighborhood; i++) {\n      let v = this.vertAt(i)\n      let distance = p.sub(point, v).lengthSquared()\n      if (distance < vertexInfo.distance) {\n        _.extend(vertexInfo, { distance: distance, vert: v, index: i })\n      }\n      poly.push(_.pick(v, 'x', 'y'))\n    }\n    let pFirst = poly[0]\n    let pLast = poly[poly.length - 1]\n    let maxY = Math.max(pFirst.y, pLast.y) + 500\n    poly.push({ x: pLast.x, y: maxY })\n    poly.push({ x: pFirst.x, y: maxY })\n    vertexInfo.polygon = poly\n\n    return vertexInfo\n  }\n\n  // test the  point against the vertexInfo.polygon\n  hitTest (point, vertexInfo) {\n    let poly = vertexInfo.polygon\n\n    // debug\n    // if (this.debugPoly) this.two.remove(this.debugPoly);\n    // let anchors = poly.map(p => new Two.Anchor(p.x, p.y));\n    // this.debugPoly = new Two.Path(anchors, true);\n    // this.debugPoly.stroke = 'Blue';\n    // this.debugPoly.noFill();\n    // this.debugPoly.lineWidth = 2;\n    // this.two.add(this.debugPoly);\n    // end debug\n\n    return _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.polyContainsPoint(poly, point)\n  }\n\n  // answer a padInfo object for the pad nearest to the passed point\n  // padInfo includes...\n  // pad - the nearest pad\n  // center - a vector representing the center of the nearest pad\n  // distance - the distance (squared) from the center to the passed point\n  //\n  padInfoNearest (point) {\n    let padCenters = this.pads.map(pad => pad.translation)\n    let baseIndex = _.sortedIndex(padCenters, { x: point.x }, 'x')\n    baseIndex = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp(baseIndex, 0, this.pads.length - 1)\n\n    // interpolate between the base and previous index\n    let baseX = this.pads[baseIndex].translation.x\n    let prevIndex = (baseIndex > 0) ? baseIndex - 1 : baseIndex\n    let prevX = this.pads[prevIndex].translation.x\n    let centerX = (baseX - prevX) / 2 + prevX\n    let index = (point.x < centerX) ? prevIndex : baseIndex\n    let nearbyPad = this.pads[index]\n\n    let segment = (new Two.Vector(point.x, point.y)).subSelf(nearbyPad.translation)\n    return { pad: nearbyPad, center: nearbyPad.translation, distance: segment.lengthSquared() }\n  }\n}\n\nconst padWidth = 80\nconst padHeight = 4\n\nclass Pad {\n  constructor (x, y) {\n    this.pad = new Two.Rectangle(x, y, padWidth, padHeight)\n    this.fill = 'Grey'\n    this.pad.noStroke()\n    this.group = new Two.Group()\n    this.group.add(this.pad)\n\n    this.textUL = new Two.Text('', x - padWidth / 4, y + padHeight + 8)\n    this.textUR = new Two.Text('', x + padWidth / 4, y + padHeight + 8)\n    this.textLC = new Two.Text('', x, y + padHeight + 24)\n    this.group.add(this.textUL, this.textUR, this.textLC)\n\n    this.textValues = { ul: { value: '', fill: 'Black' }, ur: { value: '', fill: 'Black' }, lc: { value: '', fill: 'Black' } }\n  }\n\n  landTestVx (vx) { return Math.abs(vx) < 0.007 }\n\n  landTestVy (vy) { return Math.abs(vy) < 0.02 }\n\n  landTestRotation (r) { return Math.abs(r) < 0.3 }\n\n  updateStatus (velocity, rotation) {\n    this.textValues = {\n      ul: { value: velocity.x.toFixed(3), fill: this.landTestVx(velocity.x) ? 'Green' : 'Red' },\n      ur: { value: velocity.y.toFixed(3), fill: this.landTestVy(velocity.y) ? 'Green' : 'Red' },\n      lc: { value: rotation.toFixed(3), fill: this.landTestRotation(rotation) ? 'Green' : 'Red' }\n    }\n  }\n\n  clearStatus () {\n    this.textValues = { ul: { value: '' }, ur: { value: '' }, lc: { value: '' } }\n  }\n\n  landTest (ship) {\n    let result = false\n    const vx = this.landTestVx(ship.v.x)\n    const vy = this.landTestVy(ship.v.y)\n    const r = this.landTestRotation(ship.rotation)\n    if (vx && vy && r) {\n      ship.land()\n      result = true\n    }\n    return result\n  }\n\n  // text values are { ul:{ value:'foo', fill:'Red' }, ur:{ value:'foo', fill:'Red' }, ... }\n  set textValues (textValues) {\n    if (textValues.ul) {\n      this.textUL.value = textValues.ul.value\n      if (textValues.ul.fill) this.textUL.fill = textValues.ul.fill\n    }\n    if (textValues.ur) {\n      this.textUR.value = textValues.ur.value\n      if (textValues.ur.fill) this.textUR.fill = textValues.ur.fill\n    }\n    if (textValues.lc) {\n      this.textLC.value = textValues.lc.value\n      if (textValues.lc.fill) this.textLC.fill = textValues.lc.fill\n    }\n  }\n\n  get translation () {\n    return this.pad.translation\n  }\n\n  set fill (color) {\n    this.pad.fill = color\n  }\n\n  leftAnchor () {\n    return new Two.Anchor(this.translation.x - padWidth / 2, this.translation.y - padHeight / 2)\n  }\n\n  centerAnchor () {\n    return new Two.Anchor(this.translation.x, this.translation.y - padHeight / 2)\n  }\n\n  rightAnchor () {\n    return new Two.Anchor(this.translation.x + padWidth / 2, this.translation.y - padHeight / 2)\n  }\n}\n\n//# sourceURL=webpack://neat-lunar/./src/terrain.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Utils\": () => (/* binding */ Utils)\n/* harmony export */ });\n\n\nclass Utils {\n  static clamp (number, min, max) {\n    return Math.min(Math.max(number, min), max)\n  };\n\n  static clampV (vector, min, max) {\n    vector.x = Utils.clamp(vector.x, min, max)\n    vector.y = Utils.clamp(vector.y, min, max)\n  };\n\n  static vec2string (vector, precision) {\n    precision = (precision === undefined) ? 3 : precision\n    return `${vector.x.toFixed(precision)},${vector.y.toFixed(precision)}`\n  }\n\n  // + Jonas Raoni Soares Silva\n  // @ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static polyContainsPoint (poly, point) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {\n ((poly[i].y <= point.y && point.y < poly[j].y) || (poly[j].y <= point.y && point.y < poly[i].y)) &&\n            (point.x < (poly[j].x - poly[i].x) * (point.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &&\n            (c = !c) \n}\n    return c\n  }\n\n  static canvas2Scene (p) {\n    return p.subSelf(two.scene.translation).divideScalar(two.scene.scale)\n  }\n\n  static scene2Canvas (p) {\n    return p.multiplyScalar(two.scene.scale).addSelf(two.scene.translation)\n  }\n}\n\n\n//# sourceURL=webpack://neat-lunar/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;